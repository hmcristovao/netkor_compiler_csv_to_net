/* Compiler: translate from CSV files to Network by map file
���Default format: NET (accepted by R, Gephi and Pajek)
*/

options {
	DEBUG_PARSER = false;
	DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(Compiler)

package parser;
import java.io.*;
import error.*;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;

public class Compiler {
	public static void main(String args[])  throws ParseException  {
		Compiler compiler = null;
		HashMap<String,String> hashSection1 =  new HashMap<String,String>();
		HashMap<String,String> hashSection2 =  new HashMap<String,String>();
		HashMap<String,String> hashSection3 =  new HashMap<String,String>();
		try {
			compiler = new Compiler(new FileInputStream("exemplo.map"));
			String csvFile = "exemplo.csv";

			Compiler.start(hashSection1,hashSection2,hashSection3);

			//Para impressão do arquivo .net 
         	FileWriter arq = new FileWriter("exemplo.net");
			PrintWriter gravarArq = new PrintWriter(arq);
			
			String line = "";
			int counter = 0;
			BufferedReader br = new BufferedReader(new FileReader(csvFile));
			//Lendo a primeira linha para pegar as posições das colunas que serão impressas pelo resto do csv
			//Então um loop para leiturar de todas as linhas e impressão apenas dos valores das colunas respectivas
			if((line = br.readLine()) != null)
			{
			     gravarArq.printf("*Vertices " + "--Agora complica para saber a quantidade de vértices no início do processamento :L--\n");
			  	 counter++;
			  	 
			  	 //dividindo cada coluna da linha em um vetor String
				 String[] csvFirstLine = line.split(",");
				 
				 ArrayList<Integer> posicoes = new ArrayList();
				 int primaryColumn = 0;
				 //Pegar cada elemento especificado na hash2(definido na section2)
				 for(String key : hashSection2.keySet())
			     {
					 for(int i = 0; i < csvFirstLine.length; i++)
					 {
					    //Condição para armazenando no ArrayList os valores das
					    //posições das colunas definidas na hash2
						if(key.equals(csvFirstLine[i])) posicoes.add(i);
						
						//Encontrando qual coluna está a chave primária
						else if((key.charAt(0) == '#') && csvFirstLine[i].equals(key.substring(1)))
						{
							primaryColumn = i;
						}
		   	     	}
				 }
				 //Leitura de cada linha e impressão do seu mapeamento
			 	 while((line = br.readLine()) != null)
			  	 {
			  	   			String[] csvLinesRemaining = line.split(",");
							/*
							//Aqui é para imprimir no console os valores das colunas correspondentes						
							for (Integer integer : posicoes) {
					            System.out.print (csvLinesRemaining[integer] + " ");
					        }
					        System.out.print("\n");
					        */
					        counter++;
					        gravarArq.printf("\""+ csvLinesRemaining[primaryColumn] + "\"" + "\n");
				  }
							
		     }
			 arq.close();
		/*
		//Exibir as configurações na seção 1:
			for (String key : hashSection2.keySet()) {
					
	                   //Capturamos o valor a partir da chave
	                 //  String value = hashSection2.get(key);
	                  // System.out.println(key + " = " + value);
					
         	}
		*/		
		}
		catch(FileNotFoundException e) {
			System.err.println("\nFile not found: ");
		}
		catch (IOException e) {
			System.err.println("File creation error: " + e.getMessage());
		}
		catch(TokenMgrError e) {
			System.err.println("\nLexical error: " + e.getMessage());
		}
		catch(ParseException e) {
			System.err.println("\nSintax error: " + e.getMessage());
		}
		catch(SemanticError e) {
			System.err.println("\nSemantic error: " + e.getMessage());
		}
	}
}

PARSER_END(Compiler)
 
SKIP : { " " | "\t" | "\r" | "\n" }

SKIP : { "#" : comentarioGeral }
<comentarioGeral> SKIP: { "\n" | "\n\r" | "\r\n" : DEFAULT | <~[]> }

TOKEN [IGNORE_CASE] : {
         
         < PARENTHESIS_OPEN: "(" > |
          < PARENTHESIS_CLOSE: ")" > |
          < BRACKET_OPEN: "[" > |
          < BRACKET_CLOSE: "]" > |
          < ELLIPSIS: "..." > |
          < SEMICOLON: ";" > |
          < COLON: ":" > |
          < EQUAL: "=" > |
          < TYPE_VARIABLE: "*" | ">" > |
          < NETWORK_FORMAT: "NET" | "PAJ" > |
          < LOGIC_VALUE: "TRUE" | "FALSE" > |
          < TARGET_FORMAT: "Target format" > |
          < DIRECTED_NETWORK: "Directed network" > |
          < BIPARTITE_PROJECTION: "Bipartite projection" > |
          < LAYOUT: "Layout" > |            
          < LAYOUT_NAME: "" > |
          < NO: "NO" > |
          < OR: "OR" > |
          < AND: "AND" > |
          < VARIABLES: "Variables" > |
          < NETWORK: "Network" > |
          < #LETTERCHARACTER: ["a" - "z"] | ["A" - "Z"] > |
          < #NUMBERCHARACTER: (["0"-"9"])* ((".")? ["0"-"9"])+ > |
          < #VARIABLECHARACTER: ["a" - "z", "A" - "Z" ,"0" - "9", "_"] > |
          < OPTION: < NUMBERCHARACTER > | < LETTERCHARACTER  > > |
 	     < VERTEX_NAME_WITH_QUOTE_MARK: "\"" (~["#"])* "\"" > |
 	     < HEAD_NAME_IN_CSV_OR_VARIABLE_NAME: (< LETTERCHARACTER >) 
   (< VARIABLECHARACTER > | "." )* >



}


void start(HashMap<String,String> hash1, HashMap<String,String> hash2,HashMap<String,String> hash3): { }
{
  	section1(hash1)
  	section2(hash2)
  	section3(hash3)
	{  return; }
}

void section1(HashMap<String,String>  lista):
{
  		Token t;
  		String hue = "";
}
{
  	<TARGET_FORMAT> <COLON> (t = <NETWORK_FORMAT>)
	{
	  hue = t + "";
  	  lista.put("Network Format",hue);
  	}
  	 <DIRECTED_NETWORK>
  		
  	<COLON> <LOGIC_VALUE> <BIPARTITE_PROJECTION> <COLON> (t =<LOGIC_VALUE>
  	{
	  hue = t + "";
  	  lista.put("Bipartite Projection",hue);
  	}
 	)
  	<LAYOUT> <COLON> ( t = <LAYOUT_NAME> | t =  <NO>
  	{
	  hue = t + "";
  	  lista.put("Layout Name",hue);
  	}
  	)
  	
	{  return; }
}

void section2(HashMap<String,String> hash): { }
{
	<VARIABLES> <COLON> ( variableDefinition(hash) )+
	{  return; }
}

void section3(HashMap<String,String>  lista): { }
{
  	<NETWORK> <COLON> ( vertexDefinition(lista) )+
	{  return; }
}

void variableDefinition(HashMap<String,String> hash):
{
  String typeS ="", hue = "",  hue2 = ""; Token type, name, variable;
}
{
	type = <TYPE_VARIABLE> name = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>
	(<COLON> variable = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>
	{
		hue2 = variable + "";
	}
	)?
	{
	   typeS = type + "";
	   hue = name + "";
	   if(typeS.equals("*"))
	   {
	     	hue ="#" + hue; 
			hash.put(hue,hue2);
	   }
	   else
	   {
	      hash.put(hue,hue2);
	   }
	
	}			
	{  return; }
}

void vertexDefinition(HashMap<String,String> lista): { Token t; }
{
	<VERTEX_NAME_WITH_QUOTE_MARK> <COLON>
                    ( <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME> )
                    <EQUAL> rangeExpression()
                    ((<OR>|<AND>) <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME> <EQUAL> rangeExpression())*

     {  return; }
	
}

void rangeExpression(): { }
{	  (<PARENTHESIS_OPEN> | <BRACKET_OPEN>) 
                    range() 
                   (<PARENTHESIS_CLOSE> | <BRACKET_CLOSE>)

			   | <OPTION>
		{  return; }

}

void range(): {Token t; String hue = "";}
{
	   (	     <OPTION> ( (<SEMICOLON> <OPTION>) | ( <ELLIPSIS> (<OPTION>)?) ) )
	   | (<ELLIPSIS> <OPTION>)


	   {  return; }
}
