// Compilador para mapear bases de dados primitivas para formatos de redes complexas
//
// Universidade Federal do Esp�rito Santo
// Grupo de Pesquisa: NetKOR (Networked  Knowledge Organization Retrieval)
//
// Desenvolvedores:
// Henrique Monteiro Cristov�o
// Klaus Kly Cuzzuol Wolff
// Luis Henrique Gundes Valim

options {
	DEBUG_PARSER = false;
	DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(Compiler)

package parser;
import setting.*;
import error.*;
import semantic.*;
import inOut.*;

import java.util.*;
import java.io.*;
import java.nio.file.Files;
import java.nio.charset.StandardCharsets;

public class Compiler {
	public static void main(String args[])  throws ParseException  {
		Compiler compiler = null;
		//========================================ESTRUTURAS DE DADOS=============================================//
		//====Estrutura - Secao 1
		//Contem as opcoes definidas no map a partir da section 1 e armazenadas no hashDefinition
		NetDefinition definition;
		//
		//====Estrutura - Secao 2
		//==VariableList - Lista que contem a definicoes das variaveis na section 2 e os nomes das colunas correspondentes
		VariableList variableList = new VariableList();
		//
		//====Estrutura - Secao 3
		//==vertexList	- Lista que armazena cada vertice definido na section 3
		ArrayList<Vertex> vertexList = new ArrayList<Vertex>();
		//
		//====Estruturas auxiliares
		//listPrimaryKeyVertices - Lista contendo todos os valores da coluna de primaryKey
		LinkedList<String> listPrimaryKeyVertices = new LinkedList<String>();
		//hashArc - Hash que armazena todos as expressoes validas para cada vertice do Csv 
		LinkedHashMap<Integer,ArrayList<String>> hashArcs = new LinkedHashMap<Integer,ArrayList<String>>();
		//HashBipartite
		LinkedHashMap<String, ArrayList<String>> hashBipartite = new LinkedHashMap<String,ArrayList<String>>();
		//Hash
		LinkedHashMap<String, Integer> hashVertexVariable = new LinkedHashMap<String,Integer>();
		//HashWeight
		HashMap<ArrayList<String>,Integer> hashWeight = new LinkedHashMap<ArrayList<String>,Integer>();
		try {
			//===========================================COMPILACAO===================================================//
			compiler = new Compiler(new FileInputStream(Configuration.mapFile), "UTF-8");
			definition = Compiler.start(variableList, vertexList);
			System.out.println(variableList.getVariableList());
			//------Leitura rapida do Csv para contar todas as linhas contindas no arquivo-------		
			//Metodo coutLines conta a partir de 0, portanto resulta em (valor total - 1) 
			//Com header -> Desconsidera-se o header, logo este (valor total - 1) serve
			Integer totalLinesCsv = ReaderCsv.countLines();
			//Sem header -> Como nao ha header, todas as linhas devem ser consideradas, para isso ha o incremento
			if(definition.getHeader().toLowerCase().equals("false")) totalLinesCsv++;	
			
			//========================================PRIMEIRA LEITURA DO CSV=========================================//
			//Leitura do cabecalho e armazenamento da posicao da variaveis associadas
			ReaderCsv.readColumns(variableList, definition);
			
			//========================================SEGUNDA LEITURA DO CSV==========================================//

			ReaderCsv.readAllLines(listPrimaryKeyVertices, variableList, vertexList, totalLinesCsv,
								   hashArcs, definition, hashBipartite, hashVertexVariable);

			//SemanticActions.unusedVariable(variableList);
			
			if(definition.getBipartiteProjection().toLowerCase().equals("false")) {
				totalLinesCsv++;
				SemanticActions.noNetwork(hashArcs);
				WriterNet.writeAll(listPrimaryKeyVertices, vertexList, hashArcs, hashVertexVariable, definition);
			//========================================ESCRITA DO ARQUIVO NET==========================================//
			}
			
			else {
			//========================================ESCRITA DO ARQUIVO NET==========================================//
				WriterNet.writeBipartite(vertexList, hashBipartite, hashWeight, hashVertexVariable, definition);
			}	
			
			if(SemanticActions.warnings == 1 ) {
				System.out.println("\n\n***** Successful compilation with "+SemanticActions.warnings+" warning! *****");
			}
			else if(SemanticActions.warnings > 1 ) {
				System.out.println("\n\n***** Successful compilation with "+SemanticActions.warnings+" warnings! *****");
			}
			else {
				System.out.println("\n\n***** Successful compilation! *****");
			}
		}
		catch(FileNotFoundException e) {
			System.err.println("\nFile not found: ");
		}
		catch (IOException e) {
			System.err.println("File creation error: " + e.getMessage());
		}
		catch(TokenMgrError e) {
			System.err.println("\nLexical error: " + e.getMessage());
		}
		catch(ParseException e) {
			System.err.println("\nSintax error: " + e.getMessage());
		}
		catch(SemanticError e) {
			System.err.println("\nSemantic error: " + e.getMessage());
		}
	}
}

PARSER_END(Compiler)
 
SKIP : { " " | "\t" | "\r" | "\n" }

SKIP : { "#" : comentarioGeral }
<comentarioGeral> SKIP: { "\n" | "\n\r" | "\r\n" : DEFAULT | <~[]> }

//TOKENS DE SIMBOLOS
TOKEN [IGNORE_CASE] : {
	< PARENTHESIS_OPEN: "(" > |
	< PARENTHESIS_CLOSE: ")" > |	
	< BRACKET_OPEN: "[" > |
	< BRACKET_CLOSE: "]" > |
	< ELLIPSIS: "..." > |
	< COMMA: "," > |
	< SEMICOLON: ";" > |
	< COLON: ":" > |
	< EQUAL: "=" > |
	< QUOTATION_MARK: "\"" > | 
	< TYPE_VARIABLE_PRIMARY: "*" > |
	< TYPE_VARIABLE_SECONDARY: ">" > |
	< LESSER: "<" > 
}

//PALAVRAS RESERVADAS
TOKEN [IGNORE_CASE] : {
	< SOURCE_FORMAT: "Source format" > |
	< TARGET_FORMAT: "Target format" > |
	< HEADER: "Header" > |
	< DIRECTED_NETWORK: "Directed network" > |
	< BIPARTITE_PROJECTION: "Bipartite projection" > |
	< LAYOUT: "Layout" > |            
	< VARIABLES: "Variables" > |
	< NETWORK: "Network" > |
	< COLUMN_SEPARATOR: "Column Separator" > 
}

//TOKENS DE ENTRADA PARA CONFIGURACAO
TOKEN [IGNORE_CASE] : {
	< NETWORK_FORMAT: "NET" | "PAJ" > |		//Adicionar mais formatos futuramente
	< SOURCE_FORMAT_INPUT: "CSV" > |		//Adicionar mais formatos futuramente
	< LOGIC_VALUE: "TRUE" | "FALSE" > |            
	< LAYOUT_NAME: "NOPE" > |				//Falta incluir os tipos de layout de rede
	< NO: "NO" > |
	< OR: "OR" > |
	< AND: "AND" > 
}

//----------Tokens unicos----------//
TOKEN [IGNORE_CASE] : {
	//[X...Y] / [X...Y) / (X...Y] / (X...Y)
	< FORMATELLIPSIS1: ((" ")* < BRACKET_OPEN > (" ")* < OPTION > (" ")* < ELLIPSIS > (" ")* < OPTION > (" ")* <BRACKET_CLOSE >) > |	
	< FORMATELLIPSIS2: ((" ")* < BRACKET_OPEN > (" ")* < OPTION > (" ")*  < ELLIPSIS > (" ")* < OPTION > (" ")* <PARENTHESIS_CLOSE >) > | //[x ... y)
	< FORMATELLIPSIS3: ((" ")* < PARENTHESIS_OPEN > (" ")* < OPTION > < ELLIPSIS > (" ")* < OPTION > (" ")* <BRACKET_CLOSE >) > |	//(x ... y]
	< FORMATELLIPSIS4: ((" ")* < PARENTHESIS_OPEN > (" ")* < OPTION > < ELLIPSIS > (" ")* < OPTION > (" ")* <PARENTHESIS_CLOSE >) > |	//(x ... y)
	
	// (...X) / (...X] / [X...) / (X...)
	< FORMATELLIPSIS5: ((" ")* < PARENTHESIS_OPEN > (" ")* < ELLIPSIS > (" ")*  < OPTION > (" ")* <PARENTHESIS_CLOSE >) > |
	< FORMATELLIPSIS6: ((" ")* < PARENTHESIS_OPEN > (" ")* < ELLIPSIS > (" ")*  < OPTION > (" ")* <BRACKET_CLOSE >) > |
	< FORMATELLIPSIS7: ((" ")* < BRACKET_OPEN > (" ")* < OPTION >  (" ")* < ELLIPSIS > (" ")*   <PARENTHESIS_CLOSE >) > |
	< FORMATELLIPSIS8: ((" ")* < PARENTHESIS_OPEN > (" ")* < OPTION > (" ")* < ELLIPSIS > (" ")* <PARENTHESIS_CLOSE >) > |
	< OPTION: < NUMBERCHARACTER > | < LETTERCHARACTER  > >
}

//
TOKEN [IGNORE_CASE] : {
  	< SEPARATOR: "," |  <SEMICOLON> >  |
	< #LETTERCHARACTER: ["a" - "\u00ff"] > |
	< #NUMBERCHARACTER: (["0"-"9"])* ((".")? ["0"-"9"])+ > |
	< #VARIABLECHARACTER: ["a" - "\u00ff", "0" - "9", "_"] > |
	< VERTEX_NAME_WITH_QUOTE_MARK: <QUOTATION_MARK> (~["\""])* <QUOTATION_MARK> > |
	< HEAD_NAME_IN_CSV_OR_VARIABLE_NAME: (< LETTERCHARACTER >) (< VARIABLECHARACTER > | "." )* > 
}

// Gram�tica:
//
// Start ->	section1 section 2 section 3
//
NetDefinition start(VariableList variableList, ArrayList<Vertex> vertexList) : {
	NetDefinition definition;
}
{
	definition = section1()
	section2(variableList)
	section3(vertexList, variableList)
	{
		return definition;
	}
}

// Gram�tica:
//
// section 1 ->	<SOURCE_FORMAT> <COLON> <SOURCE_FORMAT_INPUT>
//				<TARGET_NAME> <COLON> <NETWORK_FORMAT>
//				<DIRECTED_NETWORK> <COLON> <LOGIC_VALUE>
//				<BIPARTITE_PROJECTION> <COLON> <LOGIC_VALUE>
//				<LAYOUT> <COLON> (<LAYOUT_NAME> | <OR>)
//
//
NetDefinition section1() : {
	Token header, sourceFormat, networkFormat, directedNetwork, bipartiteProjection, networkLayout, separator;
	NetDefinition definition;
}
{
	<SOURCE_FORMAT> <COLON> sourceFormat = <SOURCE_FORMAT_INPUT>
	<TARGET_FORMAT> <COLON> networkFormat = <NETWORK_FORMAT>
	<HEADER> <COLON> header = <LOGIC_VALUE> 
	<DIRECTED_NETWORK> <COLON> directedNetwork = <LOGIC_VALUE> 
	<BIPARTITE_PROJECTION> <COLON> bipartiteProjection = <LOGIC_VALUE>
	<COLUMN_SEPARATOR> <COLON>  (separator = <SEMICOLON> | separator  = <COMMA>) 
	<LAYOUT> <COLON> 
	(
		networkLayout = <LAYOUT_NAME>
		|
		networkLayout = <NO> )
  		{
  	  		definition = new NetDefinition(networkFormat.image, directedNetwork.image, bipartiteProjection.image,
						networkLayout.image, header.image, sourceFormat.image, separator.image);
			return definition;
  		}
}

// Gram�tica:
//
// section2	->	<VARIABLES> <COLON> (variableDefinition)+
//
void section2(VariableList variableList): { }
{
	<VARIABLES> <COLON> (variableDefinition(variableList))+
}

// Gram�tica:
//
// variableDefinition -> ( <TYPE_VARIABLE_PRIMARY> | <TYPE_VARIABLE_SECONDARY> )
//						 <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>
//                       ( <COLON> <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME> )?
//
void variableDefinition(VariableList variableList) : {
	Token type, headNameInCsv, variableName = null;
	Variable variable;
}
{
	(  	
		(
			type = <TYPE_VARIABLE_PRIMARY>
			|
			type = <TYPE_VARIABLE_SECONDARY>
		)
		headNameInCsv = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME> 
		(
			<COLON> variableName = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>
		)?
		{
		  	if(variableName == null || variableName.image.trim().isEmpty()) variableName = headNameInCsv;
			if(type.image.equals("*")) {
				variable = new Variable(headNameInCsv.image,variableName.image,VariableType.PRIMARY, type.beginLine);
			}
			else {
				variable = new Variable(headNameInCsv.image,variableName.image,VariableType.NON_PRIMARY, type.beginLine);
			}	
			variableList.add(variable);	
		}
	)
}

// Gram�tica:
//
// section3 ->	<NETWORK> <COLON> (vertexDefinition)+
//
void section3(ArrayList<Vertex> vertexList, VariableList variableList): { }
{
  	<NETWORK> <COLON> (vertexDefinition(vertexList, variableList))+
}

// Gram�tica:
//
// vertexDefinition ->	<HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>
// 						|
// 						<VERTEX_NAME_WITH_QUOTE_MARK> <COLON> ( operationOR )+
//
void vertexDefinition(ArrayList<Vertex> vertexList, VariableList variableList):
{
  Token vertexName, vertexVariable;
  Vertex vertex2, vertex3;
  VariableList variableListVertex = new VariableList();
}
{
  	vertexVariable = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>
  	{
		vertex2 = new Vertex(vertexVariable.image, true);
	}
	optionVariable(vertex2, vertexVariable, variableList)
	{
		vertexList.add(vertex2);
	}
 	| 
	vertexName = <VERTEX_NAME_WITH_QUOTE_MARK> <COLON>
	{
		Vertex vertex = new Vertex(vertexName.image);
	}
	(
		operationOR(vertex, variableList)
		{
				vertexList.add(vertex);
		}
		(
		  	vertexVariable = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>
		  	{
		  	  	vertex3 = new Vertex(vertexVariable.image, true);
		  	}
		  	optionVariable(vertex3, vertexVariable, variableList)
			{
				vertexList.add(vertex3);
			}
		 )*
	)+
}

// Gram�tica:
//
// operationOR	->	operationAND ( <OR> operationAND)*

//	
void operationOR(Vertex expression, VariableList variableList) : {	
	Token operator;
	Item item = null;
}
{
	operationAND(expression, variableList)
	(
		operator = < OR > operationAND(expression, variableList)
		{
			item = new Operator(operator.image);
			expression.add(item);
		}
	)*   
}

// Gram�tica:
//
// operationAND	->	vertexExpression ( < AND > vertexExpression)*
//
void operationAND(Vertex expression, VariableList variableList) : {
	Token operator;
	Item item = null;  
}
{
	vertexExpression(expression, variableList)
	(
		operator = < AND > vertexExpression(expression, variableList)
		{
			item = new Operator(operator.image);
			expression.add(item);
		}
	)*
}

// Gram�tica:
//
//	vertexExpression = 	<HEAD_NAME_IN_CSV_OR_VARIABLE_NAME> <EQUAL> vertexRangeDefinition
//						| <TYPE_VARIABLE_SECONDARY> ( <EQUAL> optionDualOperator | option	)
//						| <LESSER> ( <EQUAL> optionDualOperator	| option )
//
void vertexExpression(Vertex expression, VariableList variableList) : {
	Token variable, operator, operator2;
}
{
	variable = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>
	(
		operator = <EQUAL> vertexRangeDefinition(expression, variable, operator, variableList)
		|
		operator = <TYPE_VARIABLE_SECONDARY>
		(			operator2 = <EQUAL>
			optionDualOperator(expression, variable, operator, operator2, variableList)
			|
			option(expression, variable, operator, variableList)
		)
		|
		operator = <LESSER>
		(			operator2 = <EQUAL>
			optionDualOperator(expression, variable, operator, operator2, variableList) 
			|
			option(expression, variable, operator, variableList)
		)
	)
}

// Gram�tica:
//
// vertexRangeDefinition - >  <FORMATELLIPSIS1>
//							| <FORMATELLIPSIS2>
//							| <FORMATELLIPSIS3>
//							| <FORMATELLIPSIS4> 
// 							| <FORMATELLIPSIS5>
// 							| <FORMATELLIPSIS6> 
// 							| <FORMATELLIPSIS7>
// 							| <FORMATELLIPSIS8>
// 							| rangeExpression
//
void vertexRangeDefinition(Vertex expression, Token variable, Token operator, VariableList variableList) : {
	Token expressionToken;
	Item item = null;
}
{ 
	(
    	(
	   		expressionToken = <FORMATELLIPSIS1>
	   		|
	   		expressionToken = <FORMATELLIPSIS2>
	   		|
	   		expressionToken = <FORMATELLIPSIS3>
	   		|
	   		expressionToken = <FORMATELLIPSIS4>
	   		|
	   		expressionToken = <FORMATELLIPSIS5>
	   		|
	   		expressionToken = <FORMATELLIPSIS6>
	   		|
	   		expressionToken = <FORMATELLIPSIS7>
	   		|
	   		expressionToken = <FORMATELLIPSIS8> 
	   	)
		{
			item = new Variable(VariableType.NON_PRIMARY, variable.image, variable.beginLine);
			SemanticActions.containsVariable(item, variableList, variable.beginLine);
			expression.add(item);
			expression.addInterval(expressionToken.image, item);
	 	}
	   	|
	   	rangeExpression(expression, variable, operator, variableList)
  	)
}

// Gram�tica:
//
// rangeExpression -> ( ( <PARENTHESIS_OPEN> | <BRACKET_OPEN> ) optionList ( <PARENTHESIS_CLOSE> | <BRACKET_CLOSE> ) )
//					  |	option
//
void rangeExpression(Vertex expression, Token variable, Token operator, VariableList variableList) : { }
{
	(
		(
			<PARENTHESIS_OPEN>
			|
			<BRACKET_OPEN>
		)
		optionList(expression, variable, operator, variableList)
		(
		  	<PARENTHESIS_CLOSE>
		  	|
		  	<BRACKET_CLOSE>
		)
	)
	|	option(expression, variable, operator, variableList)
}

// Gram�tica:
//
// option -> <OPTION>
//
void option(Vertex expression, Token variable, Token operator, VariableList variableList) : {
	Token opt;
	Item item = null;
}
{
	opt = <OPTION>
	{	
		item = new Variable(VariableType.NON_PRIMARY,variable.image, variable.beginLine);
		SemanticActions.containsVariable(item, variableList, variable.beginLine);
		expression.add(item);
		item = new Operand(OperandType.NUMBER, opt.image);
		expression.add(item);
		item = new Operator(operator.image);
		expression.add(item);
	}
}

void optionVariable(Vertex expression, Token variable, VariableList variableList) : {
	Item item = null;
}
{
	{	
		item = new Variable(VariableType.NON_PRIMARY,variable.image, variable.beginLine);
		SemanticActions.containsVariable(item, variableList, variable.beginLine);
		expression.add(item);
	}
}

// Gram�tica:
//
// optionDualOperator -> <OPTION>
//
void optionDualOperator(Vertex expression, Token variable, Token operator, Token operator2, VariableList variableList) : {
	Token opt;
	Item item = null;
}
{
	opt = <OPTION>
	{	
		item = new Variable(VariableType.NON_PRIMARY,variable.image, variable.beginLine);
		SemanticActions.containsVariable(item, variableList, variable.beginLine);
		expression.add(item);
		item = new Operand(OperandType.NUMBER,opt.image);
		expression.add(item);
		item = new Operator(operator.image + operator2.image);
		expression.add(item);
	}
}

// Gram�tica:
//
// optionList -> <OPTION> ( <SEMINCOLON> )?
//
void optionList(Vertex expression, Token variable, Token operator, VariableList variableList) : {
	Token option;
	Item item = null;
}
{
	option = <OPTION>
   	{
		item = new Variable(VariableType.NON_PRIMARY,variable.image, variable.beginLine);
		SemanticActions.containsVariable(item, variableList, variable.beginLine);
		expression.add(item);
		item = new Operand(OperandType.NUMBER,option.image);
		expression.add(item);
		item = new Operator(operator.image);
		expression.add(item);
	}
	(
		<SEMICOLON> optionList(expression,variable, operator, variableList)
		{
			item = new Operator("OR");
			expression.add(item);
		}
	)?
}
