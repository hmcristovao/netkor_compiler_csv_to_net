options {
	DEBUG_PARSER = false;
	DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(Compiler)

package parser;
import java.io.*;
import error.*;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import semantico.*;

public class Compiler {
	public static void main(String args[])  throws ParseException  {

		Compiler compiler = null;
		ArrayList<String> array =  new ArrayList<String>();
		LinkedList<Vertex> vertices = new LinkedList<Vertex>();
		VariableDefinition variaveis = new VariableDefinition();
		try {
			compiler = new Compiler(new FileInputStream("exemplo.map"));
			String csvFile = "exemplo.csv";
			Compiler.start(array,variaveis,vertices);
			
// INICIO_COMENTARIO
			/*
			CounterTotal serve para contar todos os vertices, tanto do section 2
			como os vertices definidos na section 3;

			Ja counterVertex e utilizado para fazer a contagem dos vertices na section 2
			para ser impresso antecipadamente no arquivo de saida .net
			*/ 
			int counterTotal = 0, counterVertex = 1;
			String line1 = "";

			//Leitura do csv para saber quantos vertices possuem ao incrementar no counterTotal
		    BufferedReader readToCount = new BufferedReader(new FileReader(csvFile));
			while((line1 = readToCount.readLine()) != null) counterTotal++;

			//Somando todos os vertices a serem gerados pela secao 3
			counterTotal += vertices.size();
			
			//Para impressão do arquivo .net
			FileWriter arq = new FileWriter("exemplo.net");
			PrintWriter gravarArq = new PrintWriter(arq);
			BufferedReader br = new BufferedReader(new FileReader(csvFile));
			String line = "";
			String count =  Integer.toString(counterTotal-1);
			//Lendo a primeira linha para pegar as posicoes das colunas que serão impressas pelo resto do csv
			//Entao um loop para leiturar de todas as linhas e impressao apenas dos valores das colunas respectivas
			if((line = br.readLine()) != null)
			{
			     gravarArq.printf("*Vertices " + count + "\n");
			  	 
			  	 //dividindo cada coluna da linha em um vetor String
				 String[] csvFirstLine = line.split(",");
				 
				 ArrayList<Integer> posicoes = new ArrayList();
				 int primaryColumn = 0;
				 
				 //Pegar cada elemento especificado na hash2(definido na section2)
				 for(Variable key : variaveis.getTabela())
			     {
					 for(int i = 0; i < csvFirstLine.length; i++)
					 {
					    //Condicao para armazenando no ArrayList os valores das
					    //posicoes das colunas definidas na hash2
						if(key.getLexema().equals(csvFirstLine[i])) posicoes.add(i);
						
						//Encontrando qual coluna esta a chave primária
						else if((key.getLexema().charAt(0) == '#') && csvFirstLine[i].equals(key.getLexema().substring(1))) primaryColumn = i;
		   	     	}
				 }
				 //Leitura de cada linha e impressao do seu mapeamento
			 	 while((line = br.readLine()) != null)
			  	 {
			  	   	String[] csvLinesRemaining = line.split(",");
					gravarArq.printf(counterVertex++ + " \"" + csvLinesRemaining[primaryColumn] + "\"" + "\n");
				 }
				 //Impressao dos vertices da section 3 
				 for(Vertex key : vertices) gravarArq.printf(counterVertex + " " + key.getVertice_name() + "\n");
			 	 
				 //Parte para impressao dos Edges e Arcs
			 	 //for() { }
			 	 gravarArq.printf("*Arcs");
			 	 gravarArq.printf("\n*Edges");			
		     }
			 arq.close();
// FIM_COMENTARIO	
		}
		catch(FileNotFoundException e) {
			System.err.println("\nFile not found: ");
		}
		catch (IOException e) {
			System.err.println("File creation error: " + e.getMessage());
		}
		catch(TokenMgrError e) {
			System.err.println("\nLexical error: " + e.getMessage());
		}
		catch(ParseException e) {
			System.err.println("\nSintax error: " + e.getMessage());
		}
		catch(SemanticError e) {
			System.err.println("\nSemantic error: " + e.getMessage());
		}
	}
}

PARSER_END(Compiler)
 
SKIP : { " " | "\t" | "\r" | "\n" }

SKIP : { "#" : comentarioGeral }
<comentarioGeral> SKIP: { "\n" | "\n\r" | "\r\n" : DEFAULT | <~[]> }

TOKEN [IGNORE_CASE] : {
          < PARENTHESIS_OPEN: "(" > |
          < PARENTHESIS_CLOSE: ")" > |
          < BRACKET_OPEN: "[" > |
          < BRACKET_CLOSE: "]" > |
          < ELLIPSIS: "..." > |
          < SEMICOLON: ";" > |
          < COLON: ":" > |
          < EQUAL: "=" > |
          < TYPE_VARIABLE: "*" | ">" > |
          < NETWORK_FORMAT: "NET" | "PAJ" > |
          < LOGIC_VALUE: "TRUE" | "FALSE" > |
          < TARGET_FORMAT: "Target format" > |
          < DIRECTED_NETWORK: "Directed network" > |
          < BIPARTITE_PROJECTION: "Bipartite projection" > |
          < LAYOUT: "Layout" > |            
          < LAYOUT_NAME: "NOPE" > |
          < NO: "NO" > |
          < OR: "OR" > |
          < AND: "AND" > |
          < VARIABLES: "Variables" > |
          < NETWORK: "Network" > |
          < #LETTERCHARACTER: ["a" - "z"] | ["A" - "Z"] > |
          < #NUMBERCHARACTER: (["0"-"9"])* ((".")? ["0"-"9"])+ > |
          < #VARIABLECHARACTER: ["a" - "z", "A" - "Z" ,"0" - "9", "_"] > |
          < OPTION: < NUMBERCHARACTER > | < LETTERCHARACTER  > > |
 	     < VERTEX_NAME_WITH_QUOTE_MARK: "\"" (~["\""])* "\"" > |
 	     < HEAD_NAME_IN_CSV_OR_VARIABLE_NAME: (< LETTERCHARACTER >) 
   (< VARIABLECHARACTER > | "." )* >
}

void start(ArrayList<String> array, VariableDefinition variaveis, LinkedList<Vertex> vertices): { }
{
  	section1(array)
  	section2(variaveis)
  	section3(vertices)
}
void section1(ArrayList<String>  array):
{
  		Token t;
}
{
  	<TARGET_FORMAT> <COLON> (t = <NETWORK_FORMAT>)
	{
  	  array.add(t.image);
  	}
  	 <DIRECTED_NETWORK>
  		
  	<COLON> <LOGIC_VALUE> <BIPARTITE_PROJECTION> <COLON> (t =<LOGIC_VALUE>
  	{
  	  array.add(t.image);
  	}
 	)
  	<LAYOUT> <COLON> ( t = <LAYOUT_NAME> | t =  <NO>
  	{
  	  array.add(t.image);
  	}
  	)
  	
	{  return; }
}

void section2(VariableDefinition variaveis):
{
	Token t;
}
{
	<VARIABLES> <COLON> ( variableDefinition(variaveis) )+
	{  return; }
}

void variableDefinition(VariableDefinition variaveis):
{
  Token t, head_name_in_csv, variable_name;
}
{
	t = <TYPE_VARIABLE> head_name_in_csv = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>
	(<COLON> variable_name = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>)?
	{
	  	// TODO: FALTA TRATAR O CASO QUANDO HA VARIABLE_NAME
		variaveis.addTabela(new Variable(t, head_name_in_csv));
	}			
	{  return; }
}

void section3(LinkedList<Vertex> vertices): { }
{
  	<NETWORK> <COLON> ( vertexDefinition(vertices) )+
	{  return; }
}


void vertexDefinition(LinkedList<Vertex> vertices): { Token v, variable, operador; Vertex vertex; }
{
    { vertex = new Vertex(); }
	v = <VERTEX_NAME_WITH_QUOTE_MARK> <COLON> variable = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>
    <EQUAL> rangeExpression(vertex)

    ((operador = <OR> | operador = <AND>) variable = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME> <EQUAL> rangeExpression(vertex)
	 { 
       vertex.addListaExpPosFixa(operador.image);
       vertex.addListaExpPosFixa(variable.image);
     }
    )*

     {
       vertex.addListaExpPosFixa(v.image);
       vertex.addListaExpPosFixa(variable.image);
       vertex.setVertice_name(v.image);
       vertices.add(vertex);
     }
     {  return; }
}

void rangeExpression(Vertex vertex): {Token a, b;}
{	  (	    (a = <PARENTHESIS_OPEN> | a = <BRACKET_OPEN>) range(vertex) (b = <PARENTHESIS_CLOSE> | b = <BRACKET_CLOSE>)
	  	{ vertex.addListaExpPosFixa(a.image);
	  	  vertex.addListaExpPosFixa(b.image);
	  	}
	  )
	  | a = <OPTION> { vertex.addListaExpPosFixa(a.image);	}

		{  return; }

}

void range(Vertex vertex): {Token op, t;}
{
	   ( op = <OPTION> ( (t = <SEMICOLON> op = <OPTION>) | ( t = <ELLIPSIS> (op = <OPTION>)?) ) )
	   | (t = <ELLIPSIS> op = <OPTION>)
	   
		{
		  vertex.addListaExpPosFixa(op.image);
	  	  vertex.addListaExpPosFixa(t.image);
	  	}	
	   {  return; }
}
