options {
	DEBUG_PARSER = false;
	DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(Compiler)

package parser;
import setting.Configuration;
import java.io.*;
import error.*;
import java.util.*;
import semantico.*;
import java.nio.file.Files;
import java.nio.charset.StandardCharsets;

public class Compiler {
	public static void main(String args[])  throws ParseException  {
		Compiler compiler = null;
		
		//Structure Section 1
		//Contem as opcoes definidas no map a partir da section 1 e armazenadas no hashDefinition
		HashMap<String,String> hashDefinition =  new HashMap<String,String>();

		//Structure Section 2
		//==varPrimaryKeyColumn	   - Variavel que armazena o nome da coluna da primary Key
		//==hashColumns			   - Hash que contem a definicoes das variaveis na section 2 e os nomes das colunas correspondentes
		String varPrimaryKeyColumn = "";
		HashMap<String,String> hashColumns = new HashMap<String,String>();

		//Structure Section 3
		//==listVertex			   - Lista que armazena cada vertice definido na section 3
		//==listExpression		   - Lista que armazena cada expressao dos vertices da section 3
		LinkedList<String> listVertex = new LinkedList<String>();
		LinkedList<ArrayList<String>> listExpression = new LinkedList<ArrayList<String>>();
		
		//Variaveis auxiliares para leitura do CSV e impressao do arquivo .NET
		//==position 		  	  - variavel responsavel em armazenar a posicao da coluna da PrimaryKey
		//==counterColumnsCsv 	  - contador utilizado para identificar as posicoes das colunas da Section 2 no csv
		//==counterLineCsv 	  	  - contador utilizado para percorrer cada linha do Csv
 		//==counterLineExpression - contador utilizado para percorrer cada expressao
 		//==counterLineNet 		  - contador utilizado para imprimir cada linha dos vertices no arquivo net resultante
 		//==totalLines 			  - total de vertices, eh a soma das linhas do Csv mais os vertices da section 3
		Integer position = 0;
		Integer counterColumnCsv = 0;
		Integer counterLineCsv = 1;
		Integer counterLineExpression = 1;
		Integer counterLineNet = 1;					
		int totalLines = 0;

		
		//Structure .Net
		//listPrimaryKeyVertices - Lista contendo todos os valores da coluna de primaryKey
		//hashVertex			 - Hash que contem o nome do vertice e a sua linha (arquivo Net)
		//hashColumnPosition	 - Hash que contem os valores das coluna das variaveis definidas na section 2 apos leitura do Csv
		//hashArc				 - Hash que armazena todos as expressoes validas para cada vertice do Csv 
		LinkedList<String> listPrimaryKeyVertices = new LinkedList<String>();
		LinkedHashMap<String,Integer> hashVertex = new LinkedHashMap<String,Integer>();
		LinkedHashMap<String,Integer> hashColumnPosition = new LinkedHashMap<String,Integer>();
		LinkedHashMap<Integer,ArrayList<Integer>> hashArcs = new LinkedHashMap<Integer,ArrayList<Integer>>();

		try {
			compiler = new Compiler(new FileInputStream(Configuration.mapFile));
			varPrimaryKeyColumn = Compiler.start(hashDefinition, varPrimaryKeyColumn, hashColumns, listExpression, listVertex);	   			

			//Tratamento das expressoes do formato token unico ao formato adequado
			//Loop que pega cada expressao da section 3 e faz um processamento de adequacao
			for(ArrayList<String> list : listExpression) {
				Expression.adjuster(list);
			}

			//Forma rapida de conseguir a quantidade de linhas o CSV possui (tambem eh leitura do csv, mas desconsiderei)
			Integer totalLinesCsv;
			LineNumberReader  lnr = new LineNumberReader(new FileReader(new File(Configuration.csvFileInput)));
			lnr.skip(Long.MAX_VALUE);
			totalLinesCsv = lnr.getLineNumber();
			lnr.close();

			////////////////////////////////////////////////////////////////////////////////////////////////////////////
			//========================================PRIMEIRA LEITURA DO CSV=========================================//
			////////////////////////////////////////////////////////////////////////////////////////////////////////////
			
			//-----------------------------------------------------Ajustar o código colocando as leitursa do csv fora do jj	//
			BufferedReader csvReader = new BufferedReader(new FileReader(Configuration.csvFileInput));										//
			String line = csvReader.readLine();																				//
			String[] columnsCsv = line.split(",");																			//
			//Loop de leitura que percorre cada coluna da primeira linha do CSV para definir 								//
			//qual a posicao da coluna da PrimaryKey Assim como as posicao das variaveis definidas na section 2				//																//
			for(String column : columnsCsv) {																				//
				if(column.equals(varPrimaryKeyColumn)) position = counterColumnCsv;											//
				else if(hashColumns.containsKey(column)) hashColumnPosition.put(hashColumns.get(column),counterColumnCsv);	//
				counterColumnCsv++;																							//
			}																												//
			csvReader.close();																								//
		
			////////////////////////////////////////////////////////////////////////////////////////////////////////////
			//========================================SEGUNDA LEITURA DO CSV==========================================//
			////////////////////////////////////////////////////////////////////////////////////////////////////////////
			
			//Pulando a leitura das primeiras linhas ja que as colunas ja foram lidas anteriormente
			BufferedReader csvReader2 = new BufferedReader(new FileReader(Configuration.csvFileInput));		
			String lineCsv = null;
			csvReader2.readLine();												
			//Leitura do CSV, para cada linha do Csv:
			//	1 ==== Preenchimento do listPrimaryKeyVertices com os valores da coluna Primary Key no Csv
			//	2 ==== Loop que avalia todas expressoes definidas na section 3 para cada linha do Csv
			//	 	   se a expressao for valida o arraylist expressions recebe a linha da expressao.
			//		   Ao final armazenando todas as expressoes validas para cada linha no hashArcs
 			while ((lineCsv = csvReader2.readLine()) != null) {
 			  	columnsCsv = lineCsv.split(",");													
	/* 1 */		listPrimaryKeyVertices.add(columnsCsv[position]);					
	/* 2 */		ArrayList<Integer> expressions = new ArrayList<Integer>();															
				counterLineExpression = 1;																	
				for(ArrayList<String> expression : listExpression) {
					if(Expression.verifierCsvExpression(expression, columnsCsv, hashColumnPosition, hashColumns)) {
						expressions.add(totalLinesCsv + counterLineExpression);
					}
					counterLineExpression++;	
				}
				hashArcs.put(counterLineCsv++,expressions);														
			}
			csvReader2.close();

			////////////////////////////////////////////////////////////////////////////////////////////////////////////
			//=======================================IMPRESSAO DO ARQUIVO NET=========================================//
			////////////////////////////////////////////////////////////////////////////////////////////////////////////

			//A impressao do arquivo net consiste de tres loops de impressao
			//	1 ==== Impressao dos vertices lidos no CSV a partir da coluna primaria definida e armazenada no listPrimaryKeyVertices
			//  2 ==== Impressao dos vertices definidos na section 3 
			totalLines = listPrimaryKeyVertices.size() + listVertex.size();

			FileWriter resultFile = new FileWriter(Configuration.csvFileOutput);									
			PrintWriter resultFileWriter = new PrintWriter(resultFile);									
  /* 1 */	resultFileWriter.printf("*Vertices " + totalLines + "\n");		
			//Impressao no arquvio net dos vertices do Csv a partir da coluna primaria:
  		 	for(String vertex : listPrimaryKeyVertices) {
				resultFileWriter.printf(counterLineNet++ +  " \"" + vertex + "\"\n");							
			}
			//Impressao no arquivo net os vertices da section 3 a partir do nome do vertice:
  /* 2 */	for(String vertex : listVertex) {
				vertex = vertex.replaceAll("\"","");
				resultFileWriter.printf(counterLineNet +  " \"" + vertex + "\"\n");
   				hashVertex.put(vertex,counterLineNet++);							
			}
  /* 3 */	resultFileWriter.printf("*Arcs " + "\n");
			//Impressao no arquivo net os arcs passando por cada Key do hashArcs e imprimindo todos seus values
			Set<Map.Entry<Integer,ArrayList<Integer>>> entries = hashArcs.entrySet();
			for (Map.Entry<Integer,ArrayList<Integer>> entry : entries) {	
				for(Integer valueExpression : entry.getValue()) {
					resultFileWriter.printf(entry.getKey() + " " + valueExpression + "\n");
				}							
			}																						
			resultFile.close();
		}
		catch(FileNotFoundException e) {
			System.err.println("\nFile not found: ");
		}
		catch (IOException e) {
			System.err.println("File creation error: " + e.getMessage());
		}
		catch(TokenMgrError e) {
			System.err.println("\nLexical error: " + e.getMessage());
		}
		catch(ParseException e) {
			System.err.println("\nSintax error: " + e.getMessage());
		}
		catch(SemanticError e) {
			System.err.println("\nSemantic error: " + e.getMessage());
		}
	}
}

PARSER_END(Compiler)
 
SKIP : { " " | "\t" | "\r" | "\n" }

SKIP : { "#" : comentarioGeral }
<comentarioGeral> SKIP: { "\n" | "\n\r" | "\r\n" : DEFAULT | <~[]> }

TOKEN [IGNORE_CASE] : {
          < PARENTHESIS_OPEN: "(" > |
          < PARENTHESIS_CLOSE: ")" > |
          < BRACKET_OPEN: "[" > |
          < BRACKET_CLOSE: "]" > |
          < ELLIPSIS: "..." > |
          < SEMICOLON: ";" > |
          < COLON: ":" > |
          < EQUAL: "=" > |
          < TYPE_VARIABLE: "*" | ">" > |
          < NETWORK_FORMAT: "NET" | "PAJ" > |
          < LOGIC_VALUE: "TRUE" | "FALSE" > |
          < TARGET_FORMAT: "Target format" > |
          < DIRECTED_NETWORK: "Directed network" > |
          < BIPARTITE_PROJECTION: "Bipartite projection" > |
          < LAYOUT: "Layout" > |            
          < LAYOUT_NAME: "NOPE" > |
          < NO: "NO" > |
          < OR: "OR" > |
          < AND: "AND" > |
          < VARIABLES: "Variables" > |
          < NETWORK: "Network" > |
          
			//[X...Y] / [X...Y) / (X...Y] / (X...Y)
		  < FORMATELLIPSIS1: ((" ")* < BRACKET_OPEN > (" ")* < OPTION > (" ")* < ELLIPSIS > (" ")* < OPTION > (" ")* <BRACKET_CLOSE >) > |	
          < FORMATELLIPSIS2: ((" ")* < BRACKET_OPEN > (" ")* < OPTION > (" ")*  < ELLIPSIS > (" ")* < OPTION > (" ")* <PARENTHESIS_CLOSE >) > |		//[x ... y)
          < FORMATELLIPSIS3: ((" ")* < PARENTHESIS_OPEN > (" ")* < OPTION > < ELLIPSIS > (" ")* < OPTION > (" ")* <BRACKET_CLOSE >) > |	//(x ... y]
          < FORMATELLIPSIS4: ((" ")* < PARENTHESIS_OPEN > (" ")* < OPTION > < ELLIPSIS > (" ")* < OPTION > (" ")* <PARENTHESIS_CLOSE >) > |	//(x ... y)
			// (...X) / (...X] / [X...) / (X...)
		  < FORMATELLIPSIS5: ((" ")* < PARENTHESIS_OPEN > (" ")* < ELLIPSIS > (" ")*  < OPTION > (" ")* <PARENTHESIS_CLOSE >) > |
		  < FORMATELLIPSIS6: ((" ")* < PARENTHESIS_OPEN > (" ")* < ELLIPSIS > (" ")*  < OPTION > (" ")* <BRACKET_CLOSE >) > |
		  < FORMATELLIPSIS7: ((" ")* < BRACKET_OPEN > (" ")* < OPTION >  (" ")* < ELLIPSIS > (" ")*   <PARENTHESIS_CLOSE >) > |
          < FORMATELLIPSIS8: ((" ")* < PARENTHESIS_OPEN > (" ")* < OPTION > (" ")* < ELLIPSIS > (" ")* <PARENTHESIS_CLOSE >) > |
 	      < OPTION: < NUMBERCHARACTER > | < LETTERCHARACTER  > > |
          < #LETTERCHARACTER: ["a" - "z"] | ["A" - "Z"] > |
          < #NUMBERCHARACTER: (["0"-"9"])* ((".")? ["0"-"9"])+ > |
          < #VARIABLECHARACTER: ["a" - "z", "A" - "Z" ,"0" - "9", "_"] > |
           
 	     < VERTEX_NAME_WITH_QUOTE_MARK: "\"" (~["\""])* "\"" > |
 	     < HEAD_NAME_IN_CSV_OR_VARIABLE_NAME: (< LETTERCHARACTER >) (< VARIABLECHARACTER > | "." )* >
}

String start(HashMap<String,String> hashDefinition, String primaryKey, HashMap<String,String> hashColumns,
			LinkedList<ArrayList<String>> listExpression, LinkedList<String> listVertex ): {  }
{
  	section1(hashDefinition)
  	primaryKey = section2(hashColumns, primaryKey)
  	section3(listExpression, listVertex)
  	{ return primaryKey; }
}
void section1(HashMap<String,String> hashDefinition):
{
  Token identification, value;
}
{
  	identification = <TARGET_FORMAT> <COLON> (value = <NETWORK_FORMAT>)
	{
  		hashDefinition.put(identification.image,value.image);
  	}	
  	identification = <DIRECTED_NETWORK> <COLON> value = <LOGIC_VALUE> 
  	{
  		hashDefinition.put(identification.image,value.image);
 	}
 	identification = <BIPARTITE_PROJECTION> <COLON> value = <LOGIC_VALUE>
 	{
  		hashDefinition.put(identification.image,value.image);
 	}
  	identification = <LAYOUT> <COLON> ( value = <LAYOUT_NAME> | value = <NO> )
  	{
  		hashDefinition.put(identification.image,value.image);
 	}
}

String section2(HashMap<String,String> hashColumns, String varPrimaryKeyColumn): { }
{
	<VARIABLES> <COLON> (varPrimaryKeyColumn = variableDefinition(hashColumns, varPrimaryKeyColumn))+
	{	return varPrimaryKeyColumn; }
}

String variableDefinition(HashMap<String,String> hashColumns, String varPrimaryKeyColumn):
{
  Token type, headNameInCsv, variableName;
}
{
	type = <TYPE_VARIABLE> headNameInCsv = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>
	{	  	
		if(type.image.equals("*")) {
		  varPrimaryKeyColumn = headNameInCsv.image;
		}
	}
	(<COLON> variableName = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>
	{
		hashColumns.put(headNameInCsv.image,variableName.image);
	}
	)?
	{
	  return varPrimaryKeyColumn;
	}
}

void section3(LinkedList<ArrayList<String>> listExpression, LinkedList<String> listVertex): { }
{
  	<NETWORK> <COLON> (vertexDefinition(listExpression, listVertex))+
}

void vertexDefinition(LinkedList<ArrayList<String>> listExpression, LinkedList<String> listVertex):
{
  Token vertexName;
  ArrayList<String> vertexExpression = new ArrayList<String>();
}
{
	vertexName = <VERTEX_NAME_WITH_QUOTE_MARK> <COLON> ( operationOR(vertexExpression)
	{
	 	listExpression.add(vertexExpression); 
	}
	)+
	{
	  	listVertex.add(vertexName.image);
	}
}


void operationOR(ArrayList<String> listExpression):
{
  Token operator;
}
{
	operationAND(listExpression) ( operator = < OR > operationAND(listExpression)
	{
		listExpression.add(operator.image);
	}
	)*   
}


void operationAND(ArrayList<String> listExpression):
{
  Token operator;
}
{
	vertexExpression(listExpression) ( operator = < AND > vertexExpression(listExpression)
	{
		listExpression.add(operator.image);
	}
	)*
}


void vertexExpression(ArrayList<String> listExpression):
{
  Token variable;
}
{
	variable = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME> <EQUAL> vertexRangeDefinition(listExpression,variable)
}

void vertexRangeDefinition(ArrayList<String> listExpression, Token variable):
{
  Token expression;
}
{
	(
    	(
	   		expression = < FORMATELLIPSIS1 > | expression = < FORMATELLIPSIS2 > |
	   		expression = < FORMATELLIPSIS3 > | expression = < FORMATELLIPSIS4 > |
	   		expression = < FORMATELLIPSIS5 > | expression = < FORMATELLIPSIS6 > |
	   		expression = < FORMATELLIPSIS7 > | expression = < FORMATELLIPSIS8 > 
	   	)
		{
	  		listExpression.add(variable.image);
	  		listExpression.add(expression.image);
		}
	   	|	rangeExpression(listExpression, variable)
  	)
}

void rangeExpression(ArrayList<String> listExpression, Token variable):
{
  Token a, b;
}
{
	(
		(a = <PARENTHESIS_OPEN> | a = <BRACKET_OPEN>)
		optionList(listExpression, variable)
		(b = <PARENTHESIS_CLOSE> | b = <BRACKET_CLOSE>)
	)
	|	a = < OPTION >
	{
		listExpression.add(variable.image);
		listExpression.add(a.image);
		listExpression.add("=");
	}
}

void optionList(ArrayList<String> listExpression, Token variable):
{
  Token option;
}
{
	option = <OPTION>
   	{
   	  	listExpression.add(variable.image);
   	  	listExpression.add(option.image);
	    listExpression.add("="); 
  	}
  	(
  		<SEMICOLON> optionList(listExpression,variable)
  	  	{
  	    	listExpression.add("OR");
  	  	}
	)?
}