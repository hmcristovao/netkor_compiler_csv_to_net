options {
	DEBUG_PARSER = false;
	DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(Compiler)

package parser;
import java.io.*;
import error.*;
import java.util.*;
import semantico.*;
import java.nio.file.Files;
import java.nio.charset.StandardCharsets;

public class Compiler {
	public static void main(String args[])  throws ParseException  {
		Compiler compiler = null;
		
		//Structure Section 1
		HashMap<String,String> hashDefinition =  new HashMap<String,String>();

		//Structure Section 2
		String varPrimaryKeyColumn = "";
		HashMap<String,String> hashColumns = new HashMap<String,String>();

		//Structure Section 3
		LinkedList<String> listVertex = new LinkedList<String>();
		LinkedList<ArrayList<String>> listExpression = new LinkedList<ArrayList<String>>();
		LinkedList<LinkedList<String>> listExpressionCorrect = new LinkedList<LinkedList<String>>();
		
		//Variaveis auxiliares para leitura do CSV e impressao do arquivo .NET
		int position = 0, counter = 0;						

		//Criar outra classe para comportar esse tipo de opcao
		String csvFile = "exemplo.csv";

		//Structure .Net
		LinkedList<String> listPrimaryKeyVertices = new LinkedList<String>();
		LinkedHashMap<String,Integer> hashVertex = new LinkedHashMap<String,Integer>();

		Vertex quebraGalho = new Vertex();
		
		try {
			compiler = new Compiler(new FileInputStream("exemplo.map"));
			varPrimaryKeyColumn = Compiler.start(hashDefinition, varPrimaryKeyColumn, hashColumns, listExpression, listVertex);	   			

			for(ArrayList<String> list : listExpression) {
				quebraGalho.ajust(list);
				System.out.println(list);
			}

			
			//------Leitura da primeira linha do CSV para definir qual a posicao da coluna da PrimaryKey------
			//
			//------------------------Ajustar o código colocando as leitursa do csv fora do jj
			BufferedReader csvRead = new BufferedReader(new FileReader("exemplo.csv"));		//
			String line = csvRead.readLine();												//
			String[] columnsCsv = line.split(",");											//
																							//
			for(String column : columnsCsv) {													//
				if(column.equals(varPrimaryKeyColumn)) position = counter;	
				counter++;  																	//
			}

			//------Leitura do CSV para alimentar listPrimaryKeyVertices, ou seja, pegar todos-------
			//--------------------os valores do PrimaryKey contidos no CSV--------------------------
			counter = 0;																	//
			File file = new File("exemplo.csv"); 											//
			List<String> linesCsv = Files.readAllLines(file.toPath(), StandardCharsets.UTF_8); //
			for (String lineReadCsv : linesCsv) {														//
				columnsCsv = lineReadCsv.split(",");													//
				listPrimaryKeyVertices.add(columnsCsv[position]);						//
				counter++;																	//
   			}

			//Preenchimento do hashVertex com todos os vertices e sua respectiva linha
			counter = 0;																	//
			int sizeNET = listPrimaryKeyVertices.size() + listVertex.size();
			// ----------------------------Gerando o .net-------------------------------
			FileWriter resultFile = new FileWriter("exemplo.net");									//
			PrintWriter resultFileWriter = new PrintWriter(resultFile);									//
			resultFileWriter.printf("*Vertices " + (sizeNET-2) + "\n");		//

			for(String vertex : listPrimaryKeyVertices) {
				if (counter != 0) {
					hashVertex.put(vertex,counter);
					resultFileWriter.printf(counter +  " \"" + vertex + "\"\n");							//
				}
				counter++;
			}

			for(String vertex : listVertex) {
				vertex = vertex.replaceAll("\"","");
				resultFileWriter.printf(counter +  " \"" + vertex + "\"\n");
   				hashVertex.put(vertex,counter++);							//
			}
			
			resultFileWriter.printf("*Arcs " + "\n");		//
			
	   																						//
			resultFile.close();
   			
   			/*						 
			//Otimizar esse processo de ordenacao
			//variaveis.sortByValue();
 
									 //Ajustar o código colocando a geracao do .net fora do jj
        	FileWriter arq = new FileWriter("exemplo.net");									//
			PrintWriter gravarArq = new PrintWriter(arq);									//
			gravarArq.printf("*Vertices " + (variaveis.setHashVertices()-1) + "\n");		//
			int count = 1;																	//
	    	for (String teste : variaveis.getHashVertices().keySet()) {						//
	          	gravarArq.printf(count +  " \"" + teste + "\"\n");							//
	          	count++;																	//
	   		}

	   		BufferedReader csvReader = new BufferedReader(new FileReader("exemplo.csv"));
			String row;
			while ((row = csvReader.readLine()) != null) {
    		strArray = row.split(",");
			for(int i = 0; i < strArray.length; i++) {
					variaveis.setHashListCSV(columnNames.get(i), strArray[i]);						// 
				}    
// do something with the data
			}
			Set<Map.Entry<String,String>> entries = variaveis.getHashListCSV().entrySet();
   			for (Map.Entry<String, String> teste : entries) {						//	          
				gravarArq.printf(teste.getKey() +  " \"" + teste.getValue() + "\"\n");							//
			}
	   																						//
			 arq.close();																	//
		*/
		}
		catch(FileNotFoundException e) {
			System.err.println("\nFile not found: ");
		}
		catch (IOException e) {
			System.err.println("File creation error: " + e.getMessage());
		}
		catch(TokenMgrError e) {
			System.err.println("\nLexical error: " + e.getMessage());
		}
		catch(ParseException e) {
			System.err.println("\nSintax error: " + e.getMessage());
		}
		catch(SemanticError e) {
			System.err.println("\nSemantic error: " + e.getMessage());
		}
	}
}

PARSER_END(Compiler)
 
SKIP : { " " | "\t" | "\r" | "\n" }

SKIP : { "#" : comentarioGeral }
<comentarioGeral> SKIP: { "\n" | "\n\r" | "\r\n" : DEFAULT | <~[]> }

TOKEN [IGNORE_CASE] : {
          < PARENTHESIS_OPEN: "(" > |
          < PARENTHESIS_CLOSE: ")" > |
          < BRACKET_OPEN: "[" > |
          < BRACKET_CLOSE: "]" > |
          < ELLIPSIS: "..." > |
          < SEMICOLON: ";" > |
          < COLON: ":" > |
          < EQUAL: "=" > |
          < TYPE_VARIABLE: "*" | ">" > |
          < NETWORK_FORMAT: "NET" | "PAJ" > |
          < LOGIC_VALUE: "TRUE" | "FALSE" > |
          < TARGET_FORMAT: "Target format" > |
          < DIRECTED_NETWORK: "Directed network" > |
          < BIPARTITE_PROJECTION: "Bipartite projection" > |
          < LAYOUT: "Layout" > |            
          < LAYOUT_NAME: "NOPE" > |
          < NO: "NO" > |
          < OR: "OR" > |
          < AND: "AND" > |
          < VARIABLES: "Variables" > |
          < NETWORK: "Network" > |
          
			//[X...Y] / [X...Y) / (X...Y] / (X...Y)
		  < FORMATELLIPSIS1: ((" ")* < BRACKET_OPEN > (" ")* < OPTION > (" ")* < ELLIPSIS > (" ")* < OPTION > (" ")* <BRACKET_CLOSE >) > |	
          < FORMATELLIPSIS2: ((" ")* < BRACKET_OPEN > (" ")* < OPTION > (" ")*  < ELLIPSIS > (" ")* < OPTION > (" ")* <PARENTHESIS_CLOSE >) > |		//[x ... y)
          < FORMATELLIPSIS3: ((" ")* < PARENTHESIS_OPEN > (" ")* < OPTION > < ELLIPSIS > (" ")* < OPTION > (" ")* <BRACKET_CLOSE >) > |	//(x ... y]
          < FORMATELLIPSIS4: ((" ")* < PARENTHESIS_OPEN > (" ")* < OPTION > < ELLIPSIS > (" ")* < OPTION > (" ")* <PARENTHESIS_CLOSE >) > |	//(x ... y)
			// (...X) / (...X] / [X...) / (X...)
		  < FORMATELLIPSIS5: ((" ")* < PARENTHESIS_OPEN > (" ")* < ELLIPSIS > (" ")*  < OPTION > (" ")* <PARENTHESIS_CLOSE >) > |
		  < FORMATELLIPSIS6: ((" ")* < PARENTHESIS_OPEN > (" ")* < ELLIPSIS > (" ")*  < OPTION > (" ")* <BRACKET_CLOSE >) > |
		  < FORMATELLIPSIS7: ((" ")* < BRACKET_OPEN > (" ")* < OPTION >  (" ")* < ELLIPSIS > (" ")*   <PARENTHESIS_CLOSE >) > |
          < FORMATELLIPSIS8: ((" ")* < PARENTHESIS_OPEN > (" ")* < OPTION > (" ")* < ELLIPSIS > (" ")* <PARENTHESIS_CLOSE >) > |
 	     < OPTION: < NUMBERCHARACTER > | < LETTERCHARACTER  > > |
          < #LETTERCHARACTER: ["a" - "z"] | ["A" - "Z"] > |
          < #NUMBERCHARACTER: (["0"-"9"])* ((".")? ["0"-"9"])+ > |
          < #VARIABLECHARACTER: ["a" - "z", "A" - "Z" ,"0" - "9", "_"] > |
           
 	     < VERTEX_NAME_WITH_QUOTE_MARK: "\"" (~["\""])* "\"" > |
 	     < HEAD_NAME_IN_CSV_OR_VARIABLE_NAME: (< LETTERCHARACTER >) (< VARIABLECHARACTER > | "." )* >
}

String start(HashMap<String,String> hashDefinition, String primaryKey, HashMap<String,String> hashColumns,
			LinkedList<ArrayList<String>> listExpression, LinkedList<String> listVertex ): {  }
{
  	section1(hashDefinition)
  	primaryKey = section2(hashColumns, primaryKey)
  	section3(listExpression, listVertex)
  	{ return primaryKey; }
}
void section1(HashMap<String,String> hashDefinition):
{
  Token identification, value;
}
{
  	identification = <TARGET_FORMAT> <COLON> (value = <NETWORK_FORMAT>)
	{
  		hashDefinition.put(identification.image,value.image);
  	}	
  	identification = <DIRECTED_NETWORK> <COLON> value = <LOGIC_VALUE> 
  	{
  		hashDefinition.put(identification.image,value.image);
 	}
 	identification = <BIPARTITE_PROJECTION> <COLON> value = <LOGIC_VALUE>
 	{
  		hashDefinition.put(identification.image,value.image);
 	}
  	identification = <LAYOUT> <COLON> ( value = <LAYOUT_NAME> | value = <NO> )
  	{
  		hashDefinition.put(identification.image,value.image);
 	}
}

String section2(HashMap<String,String> hashColumns, String varPrimaryKeyColumn): { }
{
	<VARIABLES> <COLON> (varPrimaryKeyColumn = variableDefinition(hashColumns, varPrimaryKeyColumn))+
	{	return varPrimaryKeyColumn; }
}

String variableDefinition(HashMap<String,String> hashColumns, String varPrimaryKeyColumn):
{
  Token type, headNameInCsv, variableName;
}
{
	type = <TYPE_VARIABLE> headNameInCsv = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>
	{	  	
		if(type.image.equals("*")) {
		  varPrimaryKeyColumn = headNameInCsv.image;
		}
	}
	(<COLON> variableName = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>
	{
		hashColumns.put(headNameInCsv.image,variableName.image);
	}
	)?
	{
	  return varPrimaryKeyColumn;
	}
}

void section3(LinkedList<ArrayList<String>> listExpression, LinkedList<String> listVertex): { }
{
  	<NETWORK> <COLON> (vertexDefinition(listExpression, listVertex))+
}

void vertexDefinition(LinkedList<ArrayList<String>> listExpression, LinkedList<String> listVertex):
{
  Token vertexName;
  ArrayList<String> vertexExpression = new ArrayList<String>();
}
{
	vertexName = <VERTEX_NAME_WITH_QUOTE_MARK> <COLON> ( operationOR(vertexExpression)
	{
	 	listExpression.add(vertexExpression); 
	}
	)+
	{
	  	listVertex.add(vertexName.image);
	}
}


void operationOR(ArrayList<String> listExpression):
{
  Token operator;
}
{
	operationAnd(listExpression) ( operator = < OR > operationAnd(listExpression)
	{
		listExpression.add(operator.image);
	}
	)*   
}


void operationAnd(ArrayList<String> listExpression):
{
  Token operator;
}
{
	vertexExpression(listExpression) ( operator = < AND > vertexExpression(listExpression)
	{
		listExpression.add(operator.image);
	}
	)*
}


void vertexExpression(ArrayList<String> listExpression):
{
  Token variable;
}
{
	variable = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME> <EQUAL> vertexRangeDefinition(listExpression,variable)
}

void vertexRangeDefinition(ArrayList<String> listExpression, Token variable):
{
  Token expression;
}
{
	(
    	(
	   		expression = < FORMATELLIPSIS1 > | expression = < FORMATELLIPSIS2 > |
	   		expression = < FORMATELLIPSIS3 > | expression = < FORMATELLIPSIS4 > |
	   		expression = < FORMATELLIPSIS5 > | expression = < FORMATELLIPSIS6 > |
	   		expression = < FORMATELLIPSIS7 > | expression = < FORMATELLIPSIS8 > 
	   	)
		{
	  		listExpression.add(variable.image);
	  		listExpression.add(expression.image);
		}
	   	|	rangeExpression(listExpression, variable)
  	)
}

void rangeExpression(ArrayList<String> listExpression, Token variable):
{
  Token a, b;
}
{
	(
		(a = <PARENTHESIS_OPEN> | a = <BRACKET_OPEN>)
		optionList(listExpression, variable)
		(b = <PARENTHESIS_CLOSE> | b = <BRACKET_CLOSE>)
	)
	|	a = < OPTION >
	{
		listExpression.add(variable.image);
		listExpression.add(a.image);
		listExpression.add("=");
	}
}

void optionList(ArrayList<String> listExpression, Token variable):
{
  Token option;
}
{
	option = <OPTION>
   	{
   	  	listExpression.add(variable.image);
   	  	listExpression.add(option.image);
	    listExpression.add("="); 
  	}
  	(
  		<SEMICOLON> optionList(listExpression,variable)
  	  	{
  	    	listExpression.add("OR");
  	  	}
	)?
}