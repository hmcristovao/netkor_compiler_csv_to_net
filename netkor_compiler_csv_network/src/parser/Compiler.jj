options {
	DEBUG_PARSER = false;
	DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(Compiler)

package parser;
import java.io.*;
import error.*;
import java.util.*;
import semantico.*;
import java.nio.file.Files;
import java.nio.charset.StandardCharsets;

public class Compiler {
	public static void main(String args[])  throws ParseException  {
		Compiler compiler = null;
		HashMap<String,String> hashDefinition =  new HashMap<String,String>();
		LinkedList<Vertex> vertices = new LinkedList<Vertex>();
		VariableDefinition variaveis = new VariableDefinition();
		try {
			compiler = new Compiler(new FileInputStream("exemplo.map"));
			String csvFile = "exemplo.csv";
			Compiler.start(hashDefinition,variaveis,vertices);
			for(Vertex vertice: vertices) {
				System.out.println(vertice.getLista());
			}
			/*
			variaveis.setVarPrimaryKeyColumn();			
   			variaveis.setlistVariable(vertices);
   			variaveis.setListExpressions(vertices);
   			
									//Ajustar o código colocando as leitursa do csv fora do jj
			BufferedReader brTest = new BufferedReader(new FileReader("exemplo.csv"));		//
			String text = brTest.readLine();												//
			String[] strArray = text.split(",");											//
																							//
			Integer position = 0, counter = 0;												//
			ArrayList<String> columnNames = new ArrayList<String>();
			
			for(String column : strArray) {													//
			  if(column.equals(variaveis.getVarPrimaryKeyColumn())) position = counter;		//
				columnNames.add(strArray[counter++]);  																	//
			  }																				//
			counter = 0;																	//
			File file = new File("exemplo.csv"); 											//
			List<String> lines = Files.readAllLines(file.toPath(), StandardCharsets.UTF_8); //
			for (String line : lines) {														//
				strArray = line.split(",");													//
				variaveis.addPrimaryKeyVertices(strArray[position]);						//
				counter++;																	//
   			}
   									 
			//Otimizar esse processo de ordenacao
			//variaveis.sortByValue();
 
									 //Ajustar o código colocando a geracao do .net fora do jj
        	FileWriter arq = new FileWriter("exemplo.net");									//
			PrintWriter gravarArq = new PrintWriter(arq);									//
			gravarArq.printf("*Vertices " + (variaveis.setHashVertices()-1) + "\n");		//
			int count = 1;																	//
	        for (String teste : variaveis.getHashVertices().keySet()) {						//
	          	gravarArq.printf(count +  " \"" + teste + "\"\n");							//
	          	count++;																	//
	   		}

	   		BufferedReader csvReader = new BufferedReader(new FileReader("exemplo.csv"));
			String row;
			while ((row = csvReader.readLine()) != null) {
    		strArray = row.split(",");
			for(int i = 0; i < strArray.length; i++) {
					variaveis.setHashListCSV(columnNames.get(i), strArray[i]);						// 
				}    
// do something with the data
			}
			Set<Map.Entry<String,String>> entries = variaveis.getHashListCSV().entrySet();
   			for (Map.Entry<String, String> teste : entries) {						//	          
				gravarArq.printf(teste.getKey() +  " \"" + teste.getValue() + "\"\n");							//
			}
	   																						//
			 arq.close();																	//
		*/
		}
		catch(FileNotFoundException e) {
			System.err.println("\nFile not found: ");
		}
		catch (IOException e) {
			System.err.println("File creation error: " + e.getMessage());
		}
		catch(TokenMgrError e) {
			System.err.println("\nLexical error: " + e.getMessage());
		}
		catch(ParseException e) {
			System.err.println("\nSintax error: " + e.getMessage());
		}
		catch(SemanticError e) {
			System.err.println("\nSemantic error: " + e.getMessage());
		}
	}
}

PARSER_END(Compiler)
 
SKIP : { " " | "\t" | "\r" | "\n" }

SKIP : { "#" : comentarioGeral }
<comentarioGeral> SKIP: { "\n" | "\n\r" | "\r\n" : DEFAULT | <~[]> }

TOKEN [IGNORE_CASE] : {
          < PARENTHESIS_OPEN: "(" > |
          < PARENTHESIS_CLOSE: ")" > |
          < BRACKET_OPEN: "[" > |
          < BRACKET_CLOSE: "]" > |
          < ELLIPSIS: "..." > |
          < SEMICOLON: ";" > |
          < COLON: ":" > |
          < EQUAL: "=" > |
          < TYPE_VARIABLE: "*" | ">" > |
          < NETWORK_FORMAT: "NET" | "PAJ" > |
          < LOGIC_VALUE: "TRUE" | "FALSE" > |
          < TARGET_FORMAT: "Target format" > |
          < DIRECTED_NETWORK: "Directed network" > |
          < BIPARTITE_PROJECTION: "Bipartite projection" > |
          < LAYOUT: "Layout" > |            
          < LAYOUT_NAME: "NOPE" > |
          < NO: "NO" > |
          < OR: "OR" > |
          < AND: "AND" > |
          < VARIABLES: "Variables" > |
          < NETWORK: "Network" > |
          
			//[X...Y] / [X...Y) / (X...Y] / (X...Y)
		  < FORMATELLIPSIS1: ((" ")* < BRACKET_OPEN > (" ")* < OPTION > (" ")* < ELLIPSIS > (" ")* < OPTION > (" ")* <BRACKET_CLOSE >) > |	
          < FORMATELLIPSIS2: ((" ")* < BRACKET_OPEN > (" ")* < OPTION > (" ")*  < ELLIPSIS > (" ")* < OPTION > (" ")* <PARENTHESIS_CLOSE >) > |		//[x ... y)
          < FORMATELLIPSIS3: ((" ")* < PARENTHESIS_OPEN > (" ")* < OPTION > < ELLIPSIS > (" ")* < OPTION > (" ")* <BRACKET_CLOSE >) > |	//(x ... y]
          < FORMATELLIPSIS4: ((" ")* < PARENTHESIS_OPEN > (" ")* < OPTION > < ELLIPSIS > (" ")* < OPTION > (" ")* <PARENTHESIS_CLOSE >) > |	//(x ... y)
			// (...X) / (...X] / [X...) / (X...)
		  < FORMATELLIPSIS5: ((" ")* < PARENTHESIS_OPEN > (" ")* < ELLIPSIS > (" ")*  < OPTION > (" ")* <PARENTHESIS_CLOSE >) > |
		  < FORMATELLIPSIS6: ((" ")* < PARENTHESIS_OPEN > (" ")* < ELLIPSIS > (" ")*  < OPTION > (" ")* <BRACKET_CLOSE >) > |
		  < FORMATELLIPSIS7: ((" ")* < BRACKET_OPEN > (" ")* < OPTION >  (" ")* < ELLIPSIS > (" ")*   <PARENTHESIS_CLOSE >) > |
          < FORMATELLIPSIS8: ((" ")* < PARENTHESIS_OPEN > (" ")* < OPTION > < ELLIPSIS > (" ")* <PARENTHESIS_CLOSE >) > |
 	     < OPTION: < NUMBERCHARACTER > | < LETTERCHARACTER  > > |
          < #LETTERCHARACTER: ["a" - "z"] | ["A" - "Z"] > |
          < #NUMBERCHARACTER: (["0"-"9"])* ((".")? ["0"-"9"])+ > |
          < #VARIABLECHARACTER: ["a" - "z", "A" - "Z" ,"0" - "9", "_"] > |
           
 	     < VERTEX_NAME_WITH_QUOTE_MARK: "\"" (~["\""])* "\"" > |
 	     < HEAD_NAME_IN_CSV_OR_VARIABLE_NAME: (< LETTERCHARACTER >) 
   (< VARIABLECHARACTER > | "." )* >
}

void start(HashMap<String,String> hashDefinition, VariableDefinition variaveis, LinkedList<Vertex> vertices): { }
{
  	section1(hashDefinition)
  	section2(variaveis)
  	section3(vertices)
}
void section1(HashMap<String,String> hashDefinition):
{
  Token identification, value;
}
{
  	identification = <TARGET_FORMAT> <COLON> (value = <NETWORK_FORMAT>)
	{
  		hashDefinition.put(identification.image,value.image);
  	}	
  	identification = <DIRECTED_NETWORK> <COLON> value = <LOGIC_VALUE> 
  	{
  		hashDefinition.put(identification.image,value.image);
 	}
 	identification = <BIPARTITE_PROJECTION> <COLON> value = <LOGIC_VALUE>
 	{
  		hashDefinition.put(identification.image,value.image);
 	}
  	identification = <LAYOUT> <COLON> ( value = <LAYOUT_NAME> | value = <NO> )
  	{
  		hashDefinition.put(identification.image,value.image);
 	}
}

void section2(VariableDefinition variaveis): { }
{
	<VARIABLES> <COLON> ( variableDefinition(variaveis) )+
}

void variableDefinition(VariableDefinition variaveis):
{
  Token type, headNameInCsv, variableName; Variable variable = null;
}
{
	type = <TYPE_VARIABLE> headNameInCsv = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>
	{
		variable = new Variable(headNameInCsv, type);
	}
	(<COLON> variableName = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>
	{
		variable.setVariableName(variableName);
	}
	)?
	{
		variaveis.addTabela(variable);
	}			
}

void section3(LinkedList<Vertex> vertices): { }
{
  	<NETWORK> <COLON> ( vertexDefinition(vertices) )+
}

void vertexDefinition(LinkedList<Vertex> vertices):
{
  Token v, variable;
  Vertex vertex = new Vertex();
}
{
	v = <VERTEX_NAME_WITH_QUOTE_MARK> <COLON> variable = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>
	<EQUAL>	vertexExpressionDefinition(vertex,variable) (vertexExpressionOr(vertex,variable))*
    {
    	vertex.setVertice_name(v.image);
    	vertices.add(vertex);
    }
}

void vertexExpressionDefinition(Vertex vertex, Token variable):
{
  Token expression;
}
{
	(
    	(
	   		expression = < FORMATELLIPSIS1 > | expression = < FORMATELLIPSIS2 > |
	   		expression = < FORMATELLIPSIS3 > | expression = < FORMATELLIPSIS4 > |
	   		expression = < FORMATELLIPSIS5 > | expression = < FORMATELLIPSIS6 > |
	   		expression = < FORMATELLIPSIS7 > | expression = < FORMATELLIPSIS8 > 
	   	)
		{
	  		vertex.addListaExpPosFixa(variable.image);
	  		vertex.addListaExpPosFixa(expression.image);
		}
	   	|	rangeExpression(vertex, variable)
  	)
}

void vertexExpressionOr(Vertex vertex, Token variable):
{
  Token operador = null;
}
{
	( operador = < OR > )? vertexExpressionAnd(vertex,variable)
	{
	  	if(operador!=null)	vertex.addListaExpPosFixa(operador.image);
	}
}


void vertexExpressionAnd(Vertex vertex, Token variable):
{
  Token operador = null;
}
{	( operador = < AND >)?	vertexNextExpression(vertex,variable)  
	{
		if(operador!=null)	vertex.addListaExpPosFixa(operador.image);
	}
}

void vertexNextExpression(Vertex vertex, Token variable): { }
{
	variable = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME> <EQUAL> vertexExpressionDefinition(vertex,variable)
}

void rangeExpression(Vertex vertex, Token variable):
{
  Token a, b;
}
{
	(
		(a = <PARENTHESIS_OPEN> | a = <BRACKET_OPEN>)
		optionList(vertex, variable)
		(b = <PARENTHESIS_CLOSE> | b = <BRACKET_CLOSE>)
	)
	|	a = < OPTION >
	{
		vertex.addListaExpPosFixa(variable.image);
		vertex.addListaExpPosFixa(a.image);
		vertex.addListaExpPosFixa("=");
	}
}

void optionList(Vertex vertex, Token variable):
{
  Token option;
}
{
	option = <OPTION>
   	{
   	  	vertex.addListaExpPosFixa(variable.image);
   	  	vertex.addListaExpPosFixa(option.image);
	    vertex.addListaExpPosFixa("="); 
  	}
  	(
  		<SEMICOLON> optionList(vertex,variable)
  	  	{
  	    	vertex.addListaExpPosFixa("OR");
  	  	}
	)?
}