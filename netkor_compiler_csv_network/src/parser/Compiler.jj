/////////////////////////////////////////////////////////////////////////////////////
//==Este compilador foi idealizado para preparar bases de dados em formato CSV====///
//===a formatos de entrada para softwares de redes complexas como pajek e gephi===///
/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////
//Motivacao: Iniciacao cientifica/Trabalho de concluso de curso//////////////////////
//Curso: Ciencia da computacao///////////////////////////////////////////////////////
//Campus: Sao Mateus/////////////////////////////////////////////////////////////////
//Desenvolvedores: Klaus Kly Cuzzuol Wolff e Luis Henrique Gundes Valim//////////////
//Orientador: Henrique Monteiro Cristovao////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////

options {
	DEBUG_PARSER = false;
	DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(Compiler)

package parser;
import setting.*;
import error.*;
import semantic.*;
import inOut.*;

import java.util.*;
import java.io.*;
import java.nio.file.Files;
import java.nio.charset.StandardCharsets;

public class Compiler {
	public static void main(String args[])  throws ParseException  {
		Compiler compiler = null;
		////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//========================================Estruturas de dados=============================================//
		////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//====Estrutura - Secao 1
		//Contem as opcoes definidas no map a partir da section 1 e armazenadas no hashDefinition
		NetDefinition definition;

		//====Estrutura - Secao 2
		//==VariableList - Lista que contem a definicoes das variaveis na section 2 e os nomes das colunas correspondentes
		VariableList variableList = new VariableList();
		
		//====Estrutura - Secao 3
		//==vertexList	- Lista que armazena cada vertice definido na section 3
		LinkedList<Vertex> vertexList = new LinkedList<Vertex>();

		//====Estruturas auxiliares
		//listPrimaryKeyVertices - Lista contendo todos os valores da coluna de primaryKey
		//hashVertex			 - Hash que contem o nome do vertice e a sua linha (arquivo Net)
		//hashArc				 - Hash que armazena todos as expressoes validas para cada vertice do Csv 
		LinkedList<String> listPrimaryKeyVertices = new LinkedList<String>();
		LinkedHashMap<Integer,ArrayList<Integer>> hashArcs = new LinkedHashMap<Integer,ArrayList<Integer>>();
		try {
			compiler = new Compiler(new FileInputStream(Configuration.mapFile));
			definition = Compiler.start(variableList, vertexList);

			//------Leitura rapida do Csv para contar todas as linhas contindas no arquivo-------		
			//Metodo coutLines conta a partir de 0, portanto resulta em (valor total - 1) 
			//Com header -> Desconsidera-se o header, logo este (valor total - 1) serve
			Integer totalLinesCsv = ReaderCsv.countLines();
			//Sem header -> Como nao ha header, todas as linhas devem ser consideradas, para isso ha o incremento
			if(definition.getHeader().toLowerCase().equals("false")) totalLinesCsv++;	
			
			////////////////////////////////////////////////////////////////////////////////////////////////////////////
			//========================================PRIMEIRA LEITURA DO CSV=========================================//
			////////////////////////////////////////////////////////////////////////////////////////////////////////////

			ReaderCsv.readColumns(variableList, definition);
			
			////////////////////////////////////////////////////////////////////////////////////////////////////////////
			//========================================SEGUNDA LEITURA DO CSV==========================================//
			////////////////////////////////////////////////////////////////////////////////////////////////////////////

			ReaderCsv.readAllLines(listPrimaryKeyVertices, variableList, vertexList, totalLinesCsv, hashArcs, definition);
			
			////////////////////////////////////////////////////////////////////////////////////////////////////////////
			//=======================================ESCRITA DO ARQUIVO NET===========================================//
			////////////////////////////////////////////////////////////////////////////////////////////////////////////

			SemanticActions.noNetwork(hashArcs);
			SemanticActions.unusedVariable(variableList);
			
			WriterNet.writeAll(listPrimaryKeyVertices, vertexList, hashArcs, definition);
			
			if(SemanticActions.warnings == 1 ) {
			  System.out.println("\n\n***** Successful compilation with "+SemanticActions.warnings+" warning! *****");
			}
			else if(SemanticActions.warnings > 1 ) {
			  System.out.println("\n\n***** Successful compilation with "+SemanticActions.warnings+" warnings! *****");
			}
			else {
				System.out.println("\n\n***** Successful compilation! *****");
			}
		}
		catch(FileNotFoundException e) {
			System.err.println("\nFile not found: ");
		}
		catch (IOException e) {
			System.err.println("File creation error: " + e.getMessage());
		}
		catch(TokenMgrError e) {
			System.err.println("\nLexical error: " + e.getMessage());
		}
		catch(ParseException e) {
			System.err.println("\nSintax error: " + e.getMessage());
		}
		catch(SemanticError e) {
			System.err.println("\nSemantic error: " + e.getMessage());
		}
	}
}

PARSER_END(Compiler)
 
SKIP : { " " | "\t" | "\r" | "\n" }

SKIP : { "#" : comentarioGeral }
<comentarioGeral> SKIP: { "\n" | "\n\r" | "\r\n" : DEFAULT | <~[]> }

//TOKENS DE SIMBOLOS
TOKEN [IGNORE_CASE] : {
          < PARENTHESIS_OPEN: "(" > |
          < PARENTHESIS_CLOSE: ")" > |
          < BRACKET_OPEN: "[" > |
          < BRACKET_CLOSE: "]" > |
          < ELLIPSIS: "..." > |
          < SEMICOLON: ";" > |
          < COLON: ":" > |
          < EQUAL: "=" > |
          < TYPE_VARIABLE_PRIMARY: "*" > |
          < TYPE_VARIABLE_SECONDARY: ">" > |
          < LESSER: "<" > 
}

//PALAVRAS RESERVADAS
TOKEN [IGNORE_CASE] : {
 		  < SOURCE_FORMAT: "Source format" > |
          < TARGET_FORMAT: "Target format" > |
          < HEADER: "Header" > |
          < DIRECTED_NETWORK: "Directed network" > |
          < BIPARTITE_PROJECTION: "Bipartite projection" > |
          < LAYOUT: "Layout" > |            
          < VARIABLES: "Variables" > |
          < NETWORK: "Network" > 
}

//TOKENS DE ENTRADA PARA CONFIGURACAO
TOKEN [IGNORE_CASE] : {
          < NETWORK_FORMAT: "NET" | "PAJ" > |	//Adicionar mais formatos futuramente
          < SOURCE_FORMAT_INPUT: "CSV" > |		//Adicionar mais formatos futuramente
          < LOGIC_VALUE: "TRUE" | "FALSE" > |            
          < LAYOUT_NAME: "NOPE" > |				//Falta incluir os tipos de layout de rede
          < NO: "NO" > |
          < OR: "OR" > |
          < AND: "AND" > 
}

//----------Tokens unicos----------//
TOKEN [IGNORE_CASE] : {
			//[X...Y] / [X...Y) / (X...Y] / (X...Y)
		  < FORMATELLIPSIS1: ((" ")* < BRACKET_OPEN > (" ")* < OPTION > (" ")* < ELLIPSIS > (" ")* < OPTION > (" ")* <BRACKET_CLOSE >) > |	
          < FORMATELLIPSIS2: ((" ")* < BRACKET_OPEN > (" ")* < OPTION > (" ")*  < ELLIPSIS > (" ")* < OPTION > (" ")* <PARENTHESIS_CLOSE >) > |		//[x ... y)
          < FORMATELLIPSIS3: ((" ")* < PARENTHESIS_OPEN > (" ")* < OPTION > < ELLIPSIS > (" ")* < OPTION > (" ")* <BRACKET_CLOSE >) > |	//(x ... y]
          < FORMATELLIPSIS4: ((" ")* < PARENTHESIS_OPEN > (" ")* < OPTION > < ELLIPSIS > (" ")* < OPTION > (" ")* <PARENTHESIS_CLOSE >) > |	//(x ... y)
			// (...X) / (...X] / [X...) / (X...)
		  < FORMATELLIPSIS5: ((" ")* < PARENTHESIS_OPEN > (" ")* < ELLIPSIS > (" ")*  < OPTION > (" ")* <PARENTHESIS_CLOSE >) > |
		  < FORMATELLIPSIS6: ((" ")* < PARENTHESIS_OPEN > (" ")* < ELLIPSIS > (" ")*  < OPTION > (" ")* <BRACKET_CLOSE >) > |
		  < FORMATELLIPSIS7: ((" ")* < BRACKET_OPEN > (" ")* < OPTION >  (" ")* < ELLIPSIS > (" ")*   <PARENTHESIS_CLOSE >) > |
          < FORMATELLIPSIS8: ((" ")* < PARENTHESIS_OPEN > (" ")* < OPTION > (" ")* < ELLIPSIS > (" ")* <PARENTHESIS_CLOSE >) > |
 	      < OPTION: < NUMBERCHARACTER > | < LETTERCHARACTER  > >
}

//
TOKEN [IGNORE_CASE] : {
          < #LETTERCHARACTER: ["a" - "z"] | ["A" - "Z"] > |
          < #NUMBERCHARACTER: (["0"-"9"])* ((".")? ["0"-"9"])+ > |
          < #VARIABLECHARACTER: ["a" - "z", "A" - "Z" ,"0" - "9", "_"] > |
 	      < VERTEX_NAME_WITH_QUOTE_MARK: "\"" (~["\""])* "\"" > |
 	      < HEAD_NAME_IN_CSV_OR_VARIABLE_NAME: (< LETTERCHARACTER >) (< VARIABLECHARACTER > | "." )* >
}

NetDefinition start(VariableList variableList, LinkedList<Vertex> vertexList ):
{
  NetDefinition definition;
}
{
  	definition = section1()
  	section2(variableList)
  	section3(vertexList, variableList)
  	{
  	  return definition;
  	}
}

NetDefinition section1():
{
  Token header, sourceFormat, networkFormat, directedNetwork, bipartiteProjection, networkLayout;
  NetDefinition definition;
}
{
  	<SOURCE_FORMAT> <COLON> sourceFormat = <SOURCE_FORMAT_INPUT>
 	<TARGET_FORMAT> <COLON> networkFormat = <NETWORK_FORMAT>
 	<HEADER> <COLON> header = <LOGIC_VALUE> 
  	<DIRECTED_NETWORK> <COLON> directedNetwork = <LOGIC_VALUE> 
  	<BIPARTITE_PROJECTION> <COLON> bipartiteProjection = <LOGIC_VALUE>
 	<LAYOUT> <COLON> ( networkLayout = <LAYOUT_NAME> | networkLayout = <NO> )
  	{
  	  	definition = new NetDefinition(networkFormat.image, directedNetwork.image, bipartiteProjection.image,
									networkLayout.image, header.image, sourceFormat.image);
		return definition;
  	}
}

void section2(VariableList variableList): { }
{
	<VARIABLES> <COLON> (variableDefinition(variableList))+
}

void variableDefinition(VariableList variableList):
{
  Token type, headNameInCsv, variableName = null;
  Variable variable;
}
{
	( type = <TYPE_VARIABLE_PRIMARY> | type = <TYPE_VARIABLE_SECONDARY> ) headNameInCsv = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>
	(
	  	<COLON> variableName = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME>
		{
		  	if(variableName.image.isBlank()) variableName = headNameInCsv;
		}
	)?
	{
	 	if(type.image.equals("*")) {
			variable = new Variable(headNameInCsv.image,variableName.image,VariableType.PRIMARY, type.beginLine);
		}
		else {
			variable = new Variable(headNameInCsv.image,variableName.image,VariableType.NON_PRIMARY, type.beginLine);
		}	
	  	variableList.add(variable);	
	}
}

void section3(LinkedList<Vertex> vertexList, VariableList variableList): { }
{
  	<NETWORK> <COLON> (vertexDefinition(vertexList, variableList))+
}

void vertexDefinition(LinkedList<Vertex> vertexList, VariableList variableList):
{
  Token vertexName;
}
{
	vertexName = <VERTEX_NAME_WITH_QUOTE_MARK>
	{
		Vertex vertex = new Vertex(vertexName.image);
	}
	<COLON> ( operationOR(vertex, variableList)
	{
	  	vertexList.add(vertex);
	}
	)+
}
	
void operationOR(Vertex expression, VariableList variableList):
{
  Token operator;
  Item item = null;
}
{
	operationAND(expression, variableList) ( operator = < OR > operationAND(expression, variableList)
	{
	  	item = new Operator(OperatorType.OR, operator.image);
		expression.add(item);
	}
	)*   
}

void operationAND(Vertex expression, VariableList variableList):
{
  Token operator;
  Item item = null;  
}
{
	vertexExpression(expression, variableList) ( operator = < AND > vertexExpression(expression, variableList)
	{
		item = new Operator(OperatorType.AND, operator.image);
		expression.add(item);
	}
	)*
}

void vertexExpression(Vertex expression, VariableList variableList):
{
  Token variable, operator, operator2;
}
{
	variable = <HEAD_NAME_IN_CSV_OR_VARIABLE_NAME> (
	  												operator = <EQUAL> vertexRangeDefinition(expression, variable, operator, variableList)
													| operator = <TYPE_VARIABLE_SECONDARY>
														(
													  		operator2 = <EQUAL>
	  												  		optionDualOperator(expression, variable, operator, operator2, variableList)
	  												  		|
	  												  		option(expression, variable, operator, variableList)
	  												 	)
													| operator = <LESSER>
														(														  operator2 = <EQUAL>
	  												  	  optionDualOperator(expression, variable, operator, operator2, variableList) 
														  |
														  option(expression, variable, operator, variableList)
	  													)
												   )
}

void vertexRangeDefinition(Vertex expression, Token variable, Token operator, VariableList variableList):
{
  Token expressionToken;
  Item item = null;
}
{
	(
    	(
	   		expressionToken = < FORMATELLIPSIS1 > | expressionToken = < FORMATELLIPSIS2 > |
	   		expressionToken = < FORMATELLIPSIS3 > | expressionToken = < FORMATELLIPSIS4 > |
	   		expressionToken = < FORMATELLIPSIS5 > | expressionToken = < FORMATELLIPSIS6 > |
	   		expressionToken = < FORMATELLIPSIS7 > | expressionToken = < FORMATELLIPSIS8 > 
	   	)
		{
			item = new Variable(VariableType.NON_PRIMARY, variable.image, variable.beginLine);
			SemanticActions.containsVariable(item, variableList, variable.beginLine);
			expression.add(item);
			expression.addInterval(expressionToken.image, item);
	 	}
	   	|	rangeExpression(expression, variable, operator, variableList)
  	)
}

void rangeExpression(Vertex expression, Token variable, Token operator, VariableList variableList): { }
{
	(
		( <PARENTHESIS_OPEN> | <BRACKET_OPEN> )
		optionList(expression, variable, operator, variableList)
		( <PARENTHESIS_CLOSE> | <BRACKET_CLOSE> )
	)
	|	option(expression, variable, operator, variableList)
}

void option(Vertex expression, Token variable, Token operator, VariableList variableList):
{
  Token opt;
  Item item = null;
}
{
 	opt = < OPTION >
	{	
		item = new Variable(VariableType.NON_PRIMARY,variable.image, variable.beginLine);
		SemanticActions.containsVariable(item, variableList, variable.beginLine);
		expression.add(item);
		item = new Operand(OperandType.NUMBER, opt.image);
		expression.add(item);
		item = new Operator(OperatorType.EQUAL, operator.image);
		expression.add(item);
	}
}

void optionDualOperator(Vertex expression, Token variable, Token operator, Token operator2, VariableList variableList):
{
  Token opt;
  Item item = null;
}
{
 	opt = < OPTION >
	{	
		item = new Variable(VariableType.NON_PRIMARY,variable.image, variable.beginLine);
		SemanticActions.containsVariable(item, variableList, variable.beginLine);
		expression.add(item);
		item = new Operand(OperandType.NUMBER,opt.image);
		expression.add(item);
		item = new Operator(OperatorType.EQUAL, operator.image + operator2.image);
		expression.add(item);
	}
}
  

void optionList(Vertex expression, Token variable, Token operator, VariableList variableList):
{
  Token option;
  Item item = null;
}
{
	option = <OPTION>
   	{
   	  	item = new Variable(VariableType.NON_PRIMARY,variable.image, variable.beginLine);
		SemanticActions.containsVariable(item, variableList, variable.beginLine);
		expression.add(item);
		item = new Operand(OperandType.NUMBER,option.image);
		expression.add(item);
	  	item = new Operator(OperatorType.EQUAL,operator.image);
		expression.add(item);
	}
  	(
  		<SEMICOLON> optionList(expression,variable, operator, variableList)
  	  	{
	  		item = new Operator(OperatorType.OR,"OR");
			expression.add(item);
  	  	}
	)?
}